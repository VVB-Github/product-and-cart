<!-- В этом коде прописан боковой сайд-бар и логика его -->
<template>

  <!-- Тег <aside> в HTML используется для обозначения контента, который косвенно связан с основным содержимым
    страницы. Этот контент должен иметь косвенное отношение к содержимому, окружающему его, и мог бы быть помещен
    в сторону, не потеряв при этом полного смысла. Типичные примеры использования <aside> включают боковые панели,
      рекламные блоки, блоки с информацией о авторе, тексты, поясняющие основной контент, и другие элементы, которые
      не являются критически важными для понимания основного содержания страницы. -->
    <aside class="cart-container">
      <div class="cart">
        <h1 class="cart-title spread">

          <!-- Тег <span> в HTML является строчным (inline) элементом и используется для определения части текста
            или другого контента внутри документа, для которого требуется применить определенное форматирование,
            классы или стили, или когда необходимо применить событие JavaScript к части контента без изменения его
            дисплея по умолчанию. В отличие от блочных элементов, таких как <div>, <span> не создает нового блока
            контента и не влияет на расположение или отображение соседних элементов. Тег <span> очень полезен, когда
            нужно стилизовать части текста внутри других элементов, например, внутри абзацев (<p>), заголовков или
            даже внутри других <span>, не прерывая поток документа. -->
          <span>
            Cart
            <!-- icofont-cart-alt — это класс, который относится к определенной иконке в библиотеке IcoFont, в данном
              случае, скорее всего, к иконке, изображающей корзину покупок. Это позволяет вам добавить иконку
              корзины без необходимости использовать изображения, улучшая производительность и гибкость в дизайне.
              icofont-1x — этот класс, вероятно, задает размер иконки. Библиотеки иконок часто предлагают несколько
              размеров для иконок (например, 1x, 2x, 3x и так далее), позволяя разработчикам легко контролировать
              размер иконок через CSS классы. В данном случае, 1x обозначает базовый размер иконк -->
            <i class="icofont-cart-alt icofont-1x"></i>
          </span>

          <!-- при нажатии на нижеописанную кнопку будет действовать функция toggle, она устанавливает флаг открытости
          сайд-бара в противоположный bool-еан, она импортируется из App.vue.
          &times; - нужно для оформления кнопки закрытия (x)-->
          <button @click="toggle" class="cart-close">&times;</button>
        </h1>

        <div class="cart-body">

          <!-- Тег <table> в HTML используется для создания таблицы на веб-странице.  -->
          <table class="cart-table">
            <!-- Тег <thead> используется для группирования одной или нескольких строк (<tr>) в "шапку" таблицы. -->
            <thead>
              <!-- Тег <tr> в HTML используется для определения строки таблицы -->
              <tr>
                <!-- Тег <th> в HTML используется для определения заголовочной ячейки в таблице. -->
                <th><span class="sr-only">Product Image</span></th>
                <th>Product</th>
                <th>Price</th>
                <th>Qty</th>
                <th>Total</th>
                <th><span class="sr-only">Actions</span></th>
              </tr>
            </thead>
            <tbody>

              <!-- v-for используется для рендеринга списка элементов, основываясь на массиве данных.
              (item, key, index) — это параметры, предоставляемые директивой v-for при итерации по объекту или массиву:

              item
                представляет текущий элемент массива или значение текущего свойства объекта.
              key
                (в случае объекта) представляет ключ текущего свойства объекта. Если cart является массивом,
                key также может использоваться, но чаще всего в качестве key используется index.
              index
                представляет индекс текущего элемента в массиве или порядковый номер итерации в случае объекта.
              :key="index"
                это атрибут key, который необходим для поддержания уникальности каждого элемента списка во Vue.js.
                Использование key помогает Vue оптимизировать процесс рендеринга и обновления списка, так как
                фреймворк может точно отследить, какие элементы были изменены, добавлены или удалены. Это особенно
                важно в динамически изменяющихся списках для предотвращения нежелательного поведения интерфейса и
                потенциальных ошибок.-->
              <tr v-for="(quantity, key, i) in cart" :key="i">
                <td><i class="icofont-carrot icofont-3x"></i></td>
                <!-- key - название продукта, как я понял -->
                <td>{{ key }}</td>
                <!-- получаем прайс по кею. Функция описана в этом файле -->
                <td>${{ getPrice(key) }}</td>
                <td class="center">{{ quantity }}</td>
                <!-- рассчёт суммарной цены иокругление до 2-х знаков после запятой -->
                <td>${{ (quantity * getPrice(key)).toFixed(2) }}</td>
                <td class="center">
                  <!-- при нажатии на кнопку элемент удаляется из карта. функция описывается в файле App.vue -->
                  <button @click="remove(key)" class="btn btn-light cart-remove">
                    &times;
                  </button>
                </td>
              </tr>
            </tbody>
          </table>

          <!-- Тег <em> в HTML используется для выделения текста, придавая ему эмфатическое (подчеркнутое) значение.
            Текст внутри тега <em> обычно отображается курсивом, что сигнализирует о его усиленной важности или
            интонационном акценте в предложении. Однако конкретное отображение может зависеть от стилей CSS,
            примененных к документу.
          v-if="!Object.keys(cart).length":
            Это директива условного рендеринга в Vue.js. Object.keys(cart) возвращает массив ключей объекта cart.
            Если в cart нет элементов, массив ключей будет пустым, и его длина (length) будет равна 0. Оператор !
            (логическое НЕ) инвертирует значение, так что выражение становится истинным (true), когда длина массива
            равна 0. В таком случае <p> будет отображаться.
          Object происходит из нативного JavaScript, а не из Vue.js. Object — это глобальный конструктор, который
            предоставляет набор методов и свойств для работы с объектами. Эти методы включают такие операции, как
            создание новых объектов, определение свойств объектов, и, как в приведенном вами примере, получение
            массива ключей объекта с помощью Object.keys()-->
          <p class="center" v-if="!Object.keys(cart).length"><em>No items in cart</em></p>
          <div class="spread">
            <!-- ункция calculateTotal описанна в этом файле -->
            <span><strong>Total:</strong> $ {{ calculateTotal() }}</span>
            <!-- при нажатии на кнопку совершается функция покупки -->
            <button @click="Purchase" class="btn btn-light">Purchase</button>
          </div>
        </div>
      </div>
    </aside>
</template>

<script>
export default {
  props: ['toggle', 'cart', 'inventory', 'remove', 'pastorders'],
  /* в методах мы описываем наши функции которые будут работать в этом файле, хоть их можно и экспортировать */
  methods: {
    Purchase () {
      /* this.$emit используется для создания пользовательского события. Компонент, вызывающий this.$emit,
      излучает событие вверх по дереву компонентов, позволяя родительским компонентам прослушивать эти события
      через директиву v-on (или @ в шаблонах). */
      this.$emit('addPastOrder')
      this.$emit('clearCart')
    },
    getPrice (name) {
      /* this.inventory.find((p) => { ... })
        использует метод find массива в JavaScript для поиска
        первогоэлемента в массиве this.inventory
      this
        является ключевым словом в JavaScript и имеет особое значение. Оно ссылается на контекст, в котором
        выполняется текущий код, и может отличаться в зависимости от того, где и как используется this.
        В объектно-ориентированном программировании this используется для обращения к текущему экземпляру объекта,
        в контексте которого вызывается метод. В контексте функции или метода this ссылается на объект, который
        вызвал эту функцию.
      product
        используется для хранения результата выполнения метода find на массиве this.inventory. Метод find
        итерируется по массиву this.inventory и ищет первый элемент, для которого выполнено условие, указанное в
        переданной ему функции. В данном случае условие заключается в том, что свойство name каждого объекта p в
        массиве должно строго соответствовать переменной name. Если элемент, удовлетворяющий этому условию, найден,
        find возвращает этот элемент, и он сохраняется в константе product. Если такой элемент не найден, find
        возвращает undefined.
      Синтаксис объявления переменной product похож на функцию, потому что для работы метода find используется
      функция обратного вызова (callback function). Эта функция определяет условие поиска элемента в массиве и
      передаётся в find как аргумент. В JavaScript функции являются объектами первого класса, что означает, что
      их можно передавать в другие функции в качестве аргументов, возвращать из функций, присваивать переменным
      и так далее */
      const product = this.inventory.find((p) => {
        /* Этот код является частью функции сравнения, которая проверяет, равно ли свойство name объекта p строке
        name, переданной в функцию. Код return p.name === name используется для возвращения булевого значения:
        true, если значения совпадают, и false, если нет. */
        return p.name === name
      })

      /* с помощью find мы нашли наш продукт, а потом из него в прайсах выбрали прайс в долларах США (см. food.json) */
      return product.price.USD
    },
    calculateTotal () {
      /* Эта функция вычисляет общую стоимость товаров в корзине, умножая количество каждого товара на его цену и
      суммируя полученные значения. Давайте разберем ее по шагам:
      Object.entries(this.cart)
        преобразует объект this.cart в массив массивов, где каждый вложенный массив представляет собой пару
        [ключ, значение], соответствующую имени товара и его количеству в корзине.
      reduce((acc, curr, index) => { ... }, 0)
        итерирует по этому массиву массивов, используя функцию редуктора
        для аккумулирования итоговой суммы. Инициализируется начальное значение аккумулятора 0.
      acc (аккумулятор)
        текущее промежуточное значение суммы, которое обновляется на каждом шаге итерации.
      curr (текущий элемент)
        текущий обрабатываемый элемент массива, в данном случае массив вида [ключ, значение], где ключ это
        имя товара, а значение — его количество.
      index
        индекс текущего элемента массива в процессе итерации (в данном контексте не используется).
        В теле функции редуктора выполняется выражение acc + (curr[1] * this.getPrice(curr[0])),
        которое увеличивает аккумулятор acc на произведение количества товара (curr[1]) на его цену.
        Цена товара получается вызовом функции this.getPrice(curr[0]), где curr[0] — это имя товара.
      Итак, функция берет каждую пару [имя товара, количество] из this.cart, находит цену этого товара через
      this.getPrice(имя товара), умножает количество на цену, и суммирует все такие произведения для получения
      общей стоимости товаров в корзине. */
      const total = Object.entries(this.cart).reduce((acc, curr, index) => {
        return acc + (curr[1] * this.getPrice(curr[0]))
      }, 0)
      return total.toFixed(2)
    }
  }
}
</script>
